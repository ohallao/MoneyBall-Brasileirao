# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I-158ZrEZIjTJT0qAhrM5lmP1HHQyfVa
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Função para normalizar uma métrica com base no valor máximo
def normalizar(coluna):
    return coluna / coluna.max()

# Função para gerar gráfico de radar
def radar_chart_por_jogadores(jogadores_selecionados, df):
    jogadores_filtrados = df[df['jogador'].isin(jogadores_selecionados)]

    if jogadores_filtrados.empty:
        st.write("Nenhum jogador encontrado nos nomes fornecidos.")
        return

    # Definir as métricas a serem exibidas no radar
    metrics = ['PrgR', 'xG', 'xAG', 'G-PK', 'Assistencias', 'Acoes Ofensivas']
    num_vars = len(metrics)

    # Normalizar as métricas para todos ficarem na escala [0, 1]
    jogadores_normalizados = jogadores_filtrados.copy()
    for metrica in metrics:
        min_val = df[metrica].min()
        max_val = df[metrica].max()
        jogadores_normalizados[metrica] = (jogadores_filtrados[metrica] - min_val) / (max_val - min_val)

    # Ângulos para o gráfico radar
    angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()
    angles += angles[:1]  # Fechar o círculo

    # Criar o gráfico
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))

    for _, row in jogadores_normalizados.iterrows():
        valores = row[metrics].tolist()
        valores += valores[:1]  # Fechar o círculo
        ax.plot(angles, valores, label=row['jogador'])
        ax.fill(angles, valores, alpha=0.25)

    # Adicionar os valores das métricas no gráfico
    for i, metric in enumerate(metrics):
        for _, row in jogadores_filtrados.iterrows():
            ax.text(
                angles[i],
                row[metric] / df[metric].max(),
                f"{row[metric]:.1f}",
                ha="center",
                va="bottom",
                fontsize=8
            )

    ax.set_yticks([])
    ax.set_xticks(angles[:-1])
    ax.set_xticklabels(metrics)
    plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1))
    plt.title("Comparação de Jogadores Selecionados", size=20, color='black', y=1.1)

    st.pyplot(fig)

# Configuração inicial do Streamlit
st.title("Sistema de Ranqueamento de Jogadores")

# Upload do arquivo CSV
st.sidebar.header("Upload do Arquivo")
uploaded_file = st.sidebar.file_uploader("Carregar arquivo CSV", type=["csv"])

if uploaded_file is not None:
    # Leitura do arquivo CSV
    striker = pd.read_csv(uploaded_file)

    st.write("### Dados do Arquivo")
    st.write(striker.head())

    # Configuração dos pesos para as métricas
    pesos = {
        'PrgR': 4,
        'xG': 5,
        'xAG': 4,
        'G-PK': 10.0,
        'Assistencias': 3,
        'Acoes Ofensivas': 2,
        'Aerial Duel%': 2
    }

    # Normalizando métricas específicas
    striker['Acoes Ofensivas'] = normalizar(striker['Acoes Ofensivas']) * 100
    striker['Aerial Duel%'] = normalizar(striker['Aerial Duel%']) * 100

    # Calculando as pontuações individuais para cada métrica
    for coluna, peso in pesos.items():
        striker[coluna + '_Pontuacao'] = striker[coluna] * peso

    # Calculando a pontuação total
    colunas_pontuacao = [coluna + '_Pontuacao' for coluna in pesos.keys()]
    striker['Pontuacao_Total'] = striker[colunas_pontuacao].sum(axis=1)

    # Normalizando a pontuação total no intervalo [0, 100]
    min_pontuacao = striker['Pontuacao_Total'].min()
    max_pontuacao = striker['Pontuacao_Total'].max()
    striker['Pontuacao'] = (
        (striker['Pontuacao_Total'] - min_pontuacao) / (max_pontuacao - min_pontuacao)
    ) * 100

    # Sistema de ranqueamento por perfil
    st.sidebar.header("Configuração do Perfil")
    perfil_escolhido = st.sidebar.selectbox(
        "Escolha um perfil", options=striker['Perfil'].unique()
    )

    jogadores_filtrados = striker[striker['Perfil'] == perfil_escolhido]
    jogadores_ordenados = jogadores_filtrados.sort_values(by='Pontuacao', ascending=False)

    jogadores_ordenados['Ranking'] = range(1, len(jogadores_ordenados) + 1)

    # Selecionando colunas desejadas para exibição
    resultado_final = jogadores_ordenados[
        ['Ranking', 'time', 'posicao', 'jogador', 'Perfil', 'Pontuacao']
    ]

    # Exibindo o ranking final
    st.write(f"### Ranking de jogadores no perfil: {perfil_escolhido}")
    st.write(resultado_final)

    # Baixar resultados como CSV
    csv = resultado_final.to_csv(index=False).encode('utf-8')
    st.download_button(
        label="Baixar ranking como CSV",
        data=csv,
        file_name='ranking_jogadores.csv',
        mime='text/csv',
    )

    # Gráfico de Radar para comparação de jogadores
    st.header("Comparação de Jogadores - Gráfico de Radar")

    jogadores_selecionados = st.multiselect(
        "Selecione os jogadores para comparar:", jogadores_filtrados['jogador'].unique()
    )

    if len(jogadores_selecionados) > 0:
        radar_chart_por_jogadores(jogadores_selecionados, striker)
else:
    st.write("Por favor, carregue um arquivo CSV na barra lateral.")